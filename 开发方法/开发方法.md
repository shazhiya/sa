# 开发方法

- 结构化
- 面向对象
- 面向服务
- 原型法
- 敏捷
- 构件化开发

## 软件生命周期

- 获取/供应过程: 可行性研究、需求分析
- 开发过程： 概要设计、 详细设计、 实现、 组装测试、 确认测试
- 运作阶段： 使用
- 维护阶段： 维护、退役

## 类别

- 风范
    - 自顶向下 `将一个大问题分化成多个可以解决的小问题，然后逐一进行解决。每个问题都会有一个模块去解决它，且每个问题包括抽象步骤与具体步骤。`
    - 自底向上 `自底向上法是根据系统功能要求，从具体的器件、逻辑部件或相似系统开始，凭借设计者熟练的技巧和丰富的经验，通过对其进行互相连接、修改和扩大，从而构成所需求的系统。`
- 性质
    - 形式化 `基于严密的、数学上的形式机制的计算机系统研究方法。`
    - 非形式化 `各种开发模型`
- 适用范围
    - 整体性方法
    - 局部性方法

## 结构化方法

`结构化分析、结构化设计、结构化程序设计组成。`

- 开发目标清晰化 _保持与用户沟通，让用户了解工作进展，校准工作方向。_
- 开发工作阶段化 _每个阶段完成后，要进行评审，以便于项目管理与控制。_
- 开发文档规范化 _每个阶段完成后，按照要求完成相应文档，保证系统维护工作的便利。_
- 设计方法结构化 _自顶向下分解，进行分析与设计。根据设计要求先编写各个功能模块，自底向上实现。_
- 缺点: 开发周期长、难以适应需求变化、很少考虑数据结构。

### 结构化分析 SA

`面向数据流进行需求分析，适合数据处理类型的软件。`

### 结构化设计

`要点：抽象化（过程、数据）、自顶向下逐步细化、信息隐蔽、模块独立（大小适中、扇入扇出合理、深度宽度合理）`

| 内聚   | 耦合    |
|------|-------|
| 功能内聚 | 非直接耦合 |
| 顺序内聚 | 数据耦合  |
| 通讯内聚 | 标记耦合  |
| 过程内聚 | 控制耦合  |
| 瞬时内聚 | 外部耦合  |
| 逻辑内聚 | 公共耦合  |
| 偶然内聚 | 内容耦合  |

- 自顶向下，逐层分解，把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题。
- 经过逐层分解诶，每个最低层的问题都是足够简单、容易解决的，于是复杂的问题也就迎刃而解了。

### [数据流图](数据流图.md)

### [状态转换图](状态转换图.md)

### [数据字典](数据字典.md)

## 面向对象方法

### &发展历程

`OOA/OOD/OOP组成`

- Coad/ Yourdon 方法 `强调OOA/OOD采用完全一致的概念和表示方法，使分析与设计之间不需要表示法转换。`
- Booch 方法 `开发模型包括 静态模型与动态模型， 静态模型分为逻辑模型 （类图，对象图）和物理模型 （模块图、进程图），用来描述系统的构成和结构；动态模型包括状态图和顺序图，用来描述对象的状态变化和交互过程`
- OMT 方法 `使用了建模的思想，采用对象模型（对象图）、动态模型（状态图）和功能模型 （DFD）来建立一个实际的应用模型`
- OOSE `使用用例取代DFD来进行需求分析和建立功能模型`

### 面向对象的分析

+ 模型
    + 功能模型: 用例图 `描述系统功能`
    + 行为模型(动态模型)： 活动图、顺序图、状态图 `描述系统控制结构`
    + 数据模型（对象模型）： 类图 `描述系统数据结构的对象模型`
+ [用例图](UML.md)
+ 用例建模
    + 识别参与者
    + 合并需求获得用例
    + 细化用例描述 （用例名称、简要说明、事件流(主要事件流、备选事件流)、非功能需求、前置条件、后置条件、扩展点、优先级）
    + 调整用例模型（可有可无）建立初步的用例模型后，利用用例之间的关系调整用例模型

+ 分析模型 （生成领域模型）`领域模型又称概念模型、域模型，也就是找到那些代表事物与概念的对象、即概念类。`
    + 定义概念类
    + 确定类与类之间的关系 [类图](UML.md)
    + 为类添加职责
    + 建立交互图

### 面向对象的设计

- 利用用例和用例表示需求
- 从用例模型中提炼形成领域模型，用例的实现可以用交互图表示
- 根据领域模型、用例图生成类图
- 用包图和类图形成体系结构图

+ 分析模型： 用例模型 领域模型 顶层架构图
+ 提炼： 设计用例实现方案 设计技术支撑方案 设计用户界面 细化设计模型
+ 设计模型： 架构图（包图表示） 用例实现图 （交互图表示） 类图（完整且精确） 其他 （状态图，活动图等）

## 构件（组件）化开发方法

`基于构件化的软件开发方法是解决复杂环境下软件规模与复杂性的手段`

### 区别与对象

`构件并非一定包含类，一个类元素只能属于一个构件`

| 构件         | 对象            |
|------------|---------------|
| 独立部署单元     | 一个实例单元，具有唯一标识 |
| 没有状态       | 可能具有状态，状态外部可见 |
| 作为第三方的组装单元 | 封装了自己的状态和行为   |

### &构件的获取

- 从现有构件中获取符合要求的构件，直接使用或做适应性修改，得到可以复用构件
- 通过遗留工程 （Legacy Engineering）, 将具有潜在复用价值的构件提取出来，得到可以复用的构件
- 从市场上购买现成商用构件
- 开发新的符合要求的构件

### 构件的分类、查找

- 关键字 将应用领域的盖帘按照从抽象到具体的顺序分解成树形或有相无回路图结构，每个概念用一个描述性关键字表示
- 刻面 定义若干用于刻画构件特征的刻面， 每个面包含若干概念。刻面可以描述构件功能、被操作的数据、应用的场景等
- 超文本 可以相互跳转的详细文档，通过关键字进行检索

## 面向服务的方法

`从面向构件化的方法发展而来`

- 服务总线 ESB Enterprise Service Bus (注册、部署、管理、执行服务)
- &抽象级别
    - 操作 最底层， 如单条数据的读写
    - 服务 操作的逻辑分组
    - 业务流程 最高层 为实现特定业务目标而执行的一组长期运行的动作或活动

## 原型方法 、快速原型

`与结构化方法对立，结构化方法在系统开发初期必须明确系统功能要求，确定系统边界； 原型法则 可以根据用户初步需求，利用系统工具快速建立系统模型，与用户交流`

### &划分

- 按实现方法
    - 水平原型 行为原型，用于界面。细化需求但未实现功能。
    - 垂直原型 结构化原型，用于复杂算法的实现，实现部分功能
- 按最终结果
    - 抛弃式 探索式原型，解决需求的不确定性、二义性、不完整性、含糊性等
    - 演化式 逐步演化为最终系统，用于易于升级和优化的场合，适合web项目

## 敏捷开发

### 特点

- 以人为本
- 与用户紧密协作
- 面对面沟通
- 尽早发布增量
- 小而自主的开发团队
- 适用于规模小的项目

### & 极限编程

- 更短的周期内，更早的提供具体、持续的反馈信息
- 迭代的进行计划编制，在最开始迅速生成一个总体计划，在项目开发过程中不断发展它
- 测试先行， 依赖自动测试程序来监控开发进度，并及时地捕获缺陷
- 依赖口头交流、测试和源程序进行沟通
- 倡导演化式的设计
- 依赖开发团队内部的紧密协作
- 尽可能达到程序员短期利益和项目长期利益的平衡

### SCRUM并列征求法

- product backlog: 需求列表 ，用户故事，按优先级进行排列
- sprint backlog: 按优先级取用户故事，形成冲刺周期 一般为4周
- daily meeting: 每日会议
- 燃尽图
- sprint review meeting: 冲刺周期结束购进行评审会议，决定是否发布或是再进行冲刺

# 开发模型

## 瀑布模型

`结构化方法`

- 流程步骤
  `计划、需求分析、设计、编码、测试、运维`
- 特点
    - 上一次的开发成果作为本次活动输入
    - 利用本次输入实施本活动
    - 对本次活动的成果实施评审，若成功则继续下一项活动，否则返回前一项，甚至更前项活动。
    - 需求需要明确，但现实中软件的需求很难确定，甚至不可能和不现实。
    - 交付时间长，需要很长时间才会得到软件的初始版本，如果需求变更可能损失巨大。

## 原型模型

`又称演化模型；原型方法`

- 流程步骤： 重复循环-》 交流、快速计划、快速设计方案建模、构建原型、部署交付和反馈。
- 优点 仍和功能一经开发就能进入测试，以便于验证是否符合产品需求，可以帮助引导出高质量的产品需求。
- 缺点 如果不加以控制地让用户接触开发中尚不稳点更短功能，可能对开发人员及用户都会产生负面影响。

## &螺旋模型

`属于原型模型 + 瀑布模型结合， 适用于大型复杂项目，每轮都会有风险分析`

## 喷泉模型

`面向对象方法`

- 步骤 分析、设计、实现、维护、演化
- 特点
    - 无间隙 在各项活动之间无明显边界，如分析、设计和编码之间没有明显的界限。
    - 迭代 喷泉模型在系统某个部分常常被重复工作多次，相关对象在每次迭代中随之加入渐进的系统

## &v模型

`测试模型`

- 对应关系
    - 需求分析 验收测试
    - 概要设计 系统测试
    - 详细设计 集成测试
    - 编码 单元测试

## RAD快速应用开发

`构件化开发方法， 不适合用新技术`

- 步骤 规划、设计<==>实现、运行
- 规划 用户、开发人员、管理人员确定业务需求、项目范围、系统需求等，评审后进入设计阶段
- 设计 获取需求的细节构建原型。（如报表格式、查询条件、需要那些数据等）
- 实现 编码、单元测试、系统测试
- 运行 (如准备数据、全方位测试、系统切换、用户培训等)

## RUP/UO 统一过程模型

`面相对象方法； 特点: 用例驱动，以架构为中心，迭代增量`

- 内容组织 核心工作流：商业建模、需求、分析和设计、实现、测试、部署；支持工作流: 配置和变更管理、项目管理、环境
- 时间组织 初始、细化、构建、交付； 每个时期的工作侧重点不相同

### 各级段着重事项

- 初始阶段 建立初步的系统模型，掌握大致的用户需求，定义开发环境的初步方案。
    - 明确项目规模 建立项目的软件规模和边界条件，包括验收标准；了解环境及重要的需求和约束，识别系统关键用例。
    - 评估项目风险 了解项目所面临的风险，并对如何降低或处理风险有明确的策略。
    - 制定项目计划 估计整个项目的总体成本、进度和人员配置。综合考虑备选架构，评估设计和自制、外购、复用方面方案，从而估计出成本、进度和资源
    - 阶段性技术评审 检查该阶段目标是否完成，并决定继续或取消项目。
- 细化阶段 进行详细的系统分析、设计系统的结构，进一步细化用户需求。
    - 确定架构 通过处理架构方面重要场景，建立一个已经确定基线的架构，并验证其将在适当时间、以合理的成本支持系统需求。
    - 制定构建阶段计划 为构建阶段指定详细的过程计划，并为其建立基线。
    - 建立支持环境 包括开发环境、开发流程、支持构建团队所需的工具和自动化、半自动化支持。
    - 选择构件 集成所选构件，并按主要场景进行评估
    - 阶段性技术评审 检验详细的系统目标和范围、架构的选择，以及主要风险的解决方案。
- 构建阶段 对系统进行详细设计，并进行成像编码、测试、集成等
- 移交阶段 对系统进行全面测试，补充各种文档，并吧产品移交用户等。

### 4+1视图

`四加一视图模型从五个不同的视角来描述软件体系结构。每个视图只关心系统的一个侧面，只有五个视图结合在一起才能反映系统体系的全部内容。`

- 场景 （用例视图）
    - 从外部世界的角度描述正在建模的系统功能
    - 需要使用此视图来描述系统应该执行的操作
    - 所有其他视图都依靠用例视图来指导
    - 该视图通常包含用例图、描述和概念图

- 逻辑视图
    - 描述系统各个部分的抽象描述。用于建模系统的组成部分以及各组成部分之间的交互方式。
    - 通常包括类图、对象图、状态图和协作图

- 过程（进程）视图
    - 描述系统中的进程。当可视化系统重一定会发生事情时，此视图特别有用。
    - 该视图通常包含活动图
- 开发（实现）视图
    - 描述系统的各部分如何被组织为模块和组件。管理系统体系结构中的层非常有用
    - 该视图通常包含包图、组件图
- 物理视图
    - 描述如何将前三个视图中所述的 系统设计实现为一组现实世界的实体。该视图中的图表展示了抽象部分如何映射到最终部署的系统中
    - 该视图通常包含部署图

# 软件过程管理

## &能力成熟度模型CMM

- 初始级
- 可重复级
- 已定义级
- 已管理级
- 优化级

## &能力成熟度模型集成CMMI

| 级别 | 连续式   | 阶段式   |
|----|-------|-------|
| 0  | 未完成级  |       |
| 1  | 已执行级  | 初始级   |
| 2  | 已管理级  | 已管理级  |
| 3  | 已定义级  | 已定义级  |
| 4  | 定量管理级 | 已量化级  |
| 5  | 优化级   | 持续优化级 |






